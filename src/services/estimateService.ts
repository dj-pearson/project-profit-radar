/**
 * Estimate Service
 * Updated with multi-tenant site_id isolation
 * All methods require siteId as first parameter for complete isolation
 */
import { supabase } from "@/integrations/supabase/client";

export interface Estimate {
  id: string;
  estimate_number: string;
  title: string;
  client_name: string;
  client_email?: string;
  total_amount: number;
  status: string;
  estimate_date: string;
  valid_until?: string;
  sent_date?: string;
  accepted_date?: string;
  created_at: string;
  site_id?: string;
  project?: {
    id: string;
    name: string;
  };
}

export interface EstimateStats {
  totalEstimates: number;
  pendingValue: number;
  pendingCount: number;
  conversionRate: number;
  avgResponseTime: number;
  statusCounts: {
    draft: number;
    sent: number;
    viewed: number;
    accepted: number;
    rejected: number;
    expired: number;
  };
}

class EstimateService {
  async getEstimates(siteId: string, companyId?: string): Promise<Estimate[]> {
    if (!siteId) throw new Error('Site ID is required for multi-tenant isolation');

    let query = supabase
      .from("estimates")
      .select(`
        *,
        project:projects(id, name)
      `)
      .eq("site_id", siteId)  // CRITICAL: Site isolation
      .order("created_at", { ascending: false });

    if (companyId) {
      query = query.eq("company_id", companyId);
    }

    const { data, error } = await query;

    if (error) {
      console.error("Error fetching estimates:", error);
      throw error;
    }

    return data || [];
  }

  async getEstimateStats(siteId: string, companyId?: string): Promise<EstimateStats> {
    if (!siteId) throw new Error('Site ID is required for multi-tenant isolation');

    const estimates = await this.getEstimates(siteId, companyId);
    
    const totalEstimates = estimates.length;
    
    // Calculate pending value (sent, viewed, or draft estimates)
    const pendingEstimates = estimates.filter(e => 
      ['draft', 'sent', 'viewed'].includes(e.status)
    );
    const pendingValue = pendingEstimates.reduce((sum, e) => sum + Number(e.total_amount), 0);
    const pendingCount = pendingEstimates.length;
    
    // Calculate conversion rate (accepted / total sent)
    const sentEstimates = estimates.filter(e => 
      ['sent', 'viewed', 'accepted', 'rejected'].includes(e.status)
    );
    const acceptedEstimates = estimates.filter(e => e.status === 'accepted');
    const conversionRate = sentEstimates.length > 0 
      ? Math.round((acceptedEstimates.length / sentEstimates.length) * 100)
      : 0;
    
    // Calculate average response time (days from sent to accepted/rejected)
    const respondedEstimates = estimates.filter(e => 
      e.sent_date && (e.accepted_date || e.status === 'rejected')
    );
    
    let avgResponseTime = 0;
    if (respondedEstimates.length > 0) {
      const totalResponseDays = respondedEstimates.reduce((sum, e) => {
        const sentDate = new Date(e.sent_date!);
        const responseDate = new Date(e.accepted_date || e.created_at);
        const daysDiff = Math.ceil((responseDate.getTime() - sentDate.getTime()) / (1000 * 60 * 60 * 24));
        return sum + Math.max(0, daysDiff);
      }, 0);
      avgResponseTime = Math.round((totalResponseDays / respondedEstimates.length) * 10) / 10;
    }
    
    // Count by status
    const statusCounts = {
      draft: estimates.filter(e => e.status === 'draft').length,
      sent: estimates.filter(e => e.status === 'sent').length,
      viewed: estimates.filter(e => e.status === 'viewed').length,
      accepted: estimates.filter(e => e.status === 'accepted').length,
      rejected: estimates.filter(e => e.status === 'rejected').length,
      expired: estimates.filter(e => e.status === 'expired').length,
    };

    return {
      totalEstimates,
      pendingValue,
      pendingCount,
      conversionRate,
      avgResponseTime,
      statusCounts
    };
  }

  async createEstimate(siteId: string, estimateData: {
    title: string;
    client_name: string;
    client_email?: string;
    total_amount: number;
    status?: string;
    project_id?: string;
    description?: string;
    valid_until?: string;
  }): Promise<Estimate> {
    if (!siteId) throw new Error('Site ID is required for multi-tenant isolation');

    const { data: userProfile } = await supabase
      .from("user_profiles")
      .select("company_id")
      .eq("site_id", siteId)  // CRITICAL: Site isolation
      .eq("id", (await supabase.auth.getUser()).data.user?.id)
      .single();

    if (!userProfile?.company_id) {
      throw new Error("User company not found");
    }

    const { data, error } = await supabase
      .from("estimates")
      .insert({  // CRITICAL: Site isolation
        company_id: userProfile.company_id,
        created_by: (await supabase.auth.getUser()).data.user?.id,
        estimate_number: '', // Will be auto-generated by trigger
        title: estimateData.title,
        client_name: estimateData.client_name,
        client_email: estimateData.client_email,
        total_amount: estimateData.total_amount,
        status: estimateData.status || 'draft',
        project_id: estimateData.project_id,
        description: estimateData.description,
        valid_until: estimateData.valid_until,
      })
      .select(`
        *,
        project:projects(id, name)
      `)
      .single();

    if (error) {
      console.error("Error creating estimate:", error);
      throw error;
    }

    return data;
  }

  async updateEstimate(siteId: string, estimateId: string, updates: Partial<Estimate>): Promise<Estimate> {
    if (!siteId) throw new Error('Site ID is required for multi-tenant isolation');

    const { data, error } = await supabase
      .from("estimates")
      .update(updates)
      .eq("site_id", siteId)  // CRITICAL: Site isolation
      .eq("id", estimateId)
      .select(`
        *,
        project:projects(id, name)
      `)
      .single();

    if (error) {
      console.error("Error updating estimate:", error);
      throw error;
    }

    return data;
  }

  async deleteEstimate(siteId: string, estimateId: string): Promise<void> {
    if (!siteId) throw new Error('Site ID is required for multi-tenant isolation');

    const { error } = await supabase
      .from("estimates")
      .delete()
      .eq("site_id", siteId)  // CRITICAL: Site isolation
      .eq("id", estimateId);

    if (error) {
      console.error("Error deleting estimate:", error);
      throw error;
    }
  }
}

export const estimateService = new EstimateService();